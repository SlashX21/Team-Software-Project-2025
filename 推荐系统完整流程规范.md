# 智能营养推荐系统完整流程规范

## 系统概述

本推荐系统基于多层架构设计，结合LLM大语言模型，为用户提供个性化的营养产品推荐。系统支持条码扫描和小票分析两种主要入口，通过严格的数据契约和API规范确保高质量的推荐结果。

### 技术架构
```
Flutter Frontend (62976) → Java Spring Boot (8080) → Python FastAPI (8001) → Database + OpenAI LLM
```

## 1. 系统入口和出口总览

### 1.1 主要入口类型

#### 入口1：条码扫描推荐
- **触发方式**: 用户通过Flutter应用扫描商品条码
- **数据源**: 单个商品条码 + 用户ID
- **处理目标**: 为特定商品生成营养分析和替代品推荐

#### 入口2：小票分析推荐  
- **触发方式**: 用户上传购物小票的OCR识别结果
- **数据源**: 购买商品列表 + 用户ID
- **处理目标**: 分析整体购买行为，提供购物优化建议

### 1.2 主要出口类型

#### 出口1：结构化推荐响应
```json
{
  "success": true,
  "data": {
    "recommendationId": "rec_20250710_175621_0000",
    "scanType": "barcode_scan|receipt_analysis",
    "userProfileSummary": {},
    "recommendations": [],
    "llmInsights": {},
    "processingMetadata": {}
  }
}
```

#### 出口2：前端展示组件
- **扫描页面**: 简化版AI分析展示
- **详情页面**: 完整的营养分析和推荐理由
- **历史记录**: 推荐结果的持久化存储

## 2. 详细数据流程规范

### 2.1 条码扫描推荐流程

#### Phase 1: 请求接收和验证
**请求路径**: `POST /recommendations/barcode`

**Java Controller层** (`RecommendationController.java`)
```java
@PostMapping("/barcode")
public ResponseMessage<Object> getBarcodeRecommendation(@RequestBody Map<String, Object> request) {
    // 1. 参数验证
    Integer userId = (Integer) request.get("userId");
    String productBarcode = (String) request.get("productBarcode");
    
    // 2. 创建推荐日志
    RecommendationLog log = new RecommendationLog();
    log.setUserId(userId);
    log.setRequestBarcode(productBarcode);
    log.setRequestType("barcode_scan");
    
    // 3. 调用Python推荐服务
    String recommendationServiceUrl = recommendationServiceBaseUrl + "/recommendations/barcode";
    
    return recommendationService.processRecommendation(request, log);
}
```

**请求格式规范**:
```json
{
    "userId": 4,                    // 必填: 用户ID (Integer)
    "productBarcode": "193968319465" // 必填: 商品条码 (String)
}
```

#### Phase 2: Python服务处理
**FastAPI端点** (`api/endpoints.py`)
```python
@app.post("/recommendations/barcode")
async def get_barcode_recommendations(request: BarcodeRecommendationRequest):
    try:
        # 1. 创建推荐引擎
        rec_engine = RecommendationEngine()
        
        # 2. 构建内部请求对象
        internal_request = BarcodeRecommendationRequest(
            user_id=request.userId,
            product_barcode=request.productBarcode
        )
        
        # 3. 调用推荐算法
        recommendation_response = await rec_engine.recommend_alternatives(internal_request)
        
        # 4. 格式化API响应
        return ApiResponse(success=True, data=recommendation_response.to_dict())
        
    except Exception as e:
        logger.error(f"Barcode recommendation failed: {e}")
        return ApiResponse(success=False, error=str(e))
```

#### Phase 3: 推荐算法执行
**核心推荐引擎** (`recommendation/recommender.py`)

```python
async def recommend_alternatives(self, request: BarcodeRecommendationRequest) -> RecommendationResponse:
    # Step 1: 加载用户画像
    user_profile = await self._load_user_profile(request.user_id)
    
    # Step 2: 获取原始产品信息
    original_product = await self._get_product_by_barcode(request.product_barcode)
    
    # Step 3: 获取候选推荐商品
    candidates = await self._get_candidate_products(original_product)
    
    # Step 4: 应用硬过滤器
    filtered_candidates = await self._apply_hard_filters(candidates, user_profile)
    
    # Step 5: 营养优化评分
    scored_candidates = await self._apply_nutrition_optimization(filtered_candidates, user_profile)
    
    # Step 6: 生成最终推荐列表
    final_recommendations = scored_candidates[:self.config.max_recommendations]
    
    # Step 7: LLM分析生成
    llm_insights = await self._generate_llm_analysis(
        original_product, 
        final_recommendations, 
        user_profile
    )
    
    # Step 8: 构建响应对象
    return RecommendationResponse(
        recommendation_id=self._generate_recommendation_id(),
        scan_type="barcode_scan",
        user_profile_summary=user_profile,
        recommendations=final_recommendations,
        llmInsights=llm_insights,
        processing_metadata=self._get_processing_metadata()
    )
```

#### Phase 4: LLM分析生成
**LLM客户端调用** (`llm_evaluation/openai_client.py`)

```python
async def generate_barcode_analysis(self, context: PromptContext) -> Dict[str, Any]:
    # 1. 构建Prompt模板
    template_manager = get_template_manager()
    prompt = template_manager.generate_barcode_scan_prompt(context)
    
    # 2. 调用OpenAI API
    response = await self.client.chat.completions.create(
        model=self.model_name,
        messages=[
            {"role": "system", "content": "You are a professional nutritionist."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=self.max_tokens,
        temperature=0.7
    )
    
    # 3. 解析JSON响应
    content = response.choices[0].message.content
    llm_data = json.loads(content)
    
    # 4. 数据验证和清理
    return self._validate_llm_response(llm_data)
```

**LLM输出格式规范**:
```json
{
    "summary": "Given your Health Maintenance goal and Moderate Activity level, the scanned product has excessive sugar and calorie content that may hinder your objectives.",
    "detailedAnalysis": "The Lemon Blueberry Soft Baked Clusters contain 34.29g of sugar per 100g, which is quite high and might not align with your health maintenance goals...",
    "actionSuggestions": [
        "Consider limiting the intake of high-sugar products like the scanned item and alternatives.",
        "Focus on incorporating a variety of foods that provide balanced macronutrients to meet your daily targets.",
        "Monitor portion sizes of the recommended alternatives to manage calorie intake effectively."
    ]
}
```

### 2.2 小票分析推荐流程

#### Phase 1: 请求接收
**请求路径**: `POST /recommendations/receipt`

**请求格式规范**:
```json
{
    "userId": 1,
    "purchasedItems": [
        {
            "productName": "Coca Cola Original 330ml",
            "quantity": 2
        },
        {
            "productName": "Milk Whole 1L",
            "quantity": 1
        }
    ]
}
```

#### Phase 2: 产品名称解析
**Java Service层** (`RecommendationService.java`)
```java
// 将产品名称转换为条码
List<String> barcodes = new ArrayList<>();
for (Map<String, Object> item : purchasedItems) {
    String productName = (String) item.get("productName");
    String barcode = productService.findBarcodeByName(productName);
    if (barcode != null) {
        barcodes.add(barcode);
    }
}
```

#### Phase 3: 批量推荐处理
**Python批量处理** (`recommendation/recommender.py`)
```python
async def analyze_receipt(self, request: ReceiptRecommendationRequest) -> RecommendationResponse:
    batch_results = []
    
    for item in request.purchased_items:
        # 对每个商品单独进行推荐分析
        item_analysis = await self._analyze_single_receipt_item(item, request.user_id)
        batch_results.append(item_analysis)
    
    # 生成整体营养评估
    overall_analysis = await self._generate_overall_receipt_analysis(batch_results, request.user_id)
    
    return overall_analysis
```

## 3. 数据契约规范

### 3.1 用户画像数据契约

```json
{
    "userId": 4,
    "age": 28,
    "gender": "male",
    "height_cm": 175,
    "weight_kg": 70,
    "nutrition_goal": "WEIGHT_LOSS",
    "activity_level": "MODERATE",
    "allergens": ["Fish", "Peanuts", "Sulfites"],
    "daily_calories_target": 2000
}
```

### 3.2 产品信息数据契约

```json
{
    "barcode": "193968319465",
    "name": "Lemon Blueberry Soft Baked Clusters",
    "brand": "Members Mark",
    "category": "Food",
    "nutrition": {
        "energy_kcal_100g": 400.0,
        "proteins_100g": 5.71,
        "fat_100g": 14.29,
        "carbohydrates_100g": 45.71,
        "sugars_100g": 34.29,
        "fiber_100g": 2.86,
        "salt_100g": 0.57
    },
    "ingredients": "Oats, sugar, blueberries (10%), lemon flavoring...",
    "allergens": ["Gluten", "May contain nuts"]
}
```

### 3.3 推荐结果数据契约

```json
{
    "rank": 1,
    "product": {
        "barcode": "12345678901",
        "name": "Cadbury dairy milk chocolate bar wholenut",
        "brand": "Cadbury",
        "nutrition": {...},
        "recommendation_score": 0.85
    },
    "nutrition_improvement": {
        "protein_increase": "+61%",
        "sugar_reduction": "-31%",
        "calorie_change": "+36%"
    },
    "safety_check": {
        "allergen_safe": true,
        "nutrition_goal_aligned": true,
        "activity_level_suitable": true
    },
    "reasoning": "Choose Cadbury for higher protein and nut content, supporting health goals better."
}
```

## 4. API响应格式规范

### 4.1 成功响应格式

```json
{
    "success": true,
    "message": "推荐获取成功",
    "data": {
        "recommendation_id": "rec_20250710_175621_0000",
        "scan_type": "barcode_scan",
        "user_profile_summary": {
            "userId": 4,
            "nutrition_goal": "WEIGHT_LOSS",
            "activity_level": "MODERATE",
            "allergen_count": 3
        },
        "recommendations": [
            {
                "rank": 1,
                "product": {...},
                "recommendation_score": 0.85,
                "nutrition_improvement": {...},
                "safety_check": {...},
                "reasoning": "..."
            }
        ],
        "llmInsights": {
            "summary": "...",
            "detailedAnalysis": "...",
            "actionSuggestions": [...]
        },
        "processing_metadata": {
            "algorithmVersion": "v1.0",
            "processingTimeMs": 5401,
            "llmTokensUsed": 450,
            "confidenceScore": 0.85,
            "totalCandidates": 200,
            "filteredCandidates": 50,
            "timestamp": "2025-07-10T18:59:21.874Z"
        }
    },
    "timestamp": "2025-07-10T18:59:21.874Z",
    "error": null
}
```

### 4.2 错误响应格式

```json
{
    "success": false,
    "message": "推荐生成失败",
    "data": null,
    "error": {
        "code": "RECOMMENDATION_ERROR",
        "message": "Product not found with barcode: 123456789",
        "details": {
            "barcode": "123456789",
            "userId": 4,
            "timestamp": "2025-07-10T18:59:21.874Z"
        }
    },
    "timestamp": "2025-07-10T18:59:21.874Z"
}
```

## 5. 算法层级和过滤器规范

### 5.1 硬过滤器 (Hard Filters)

#### 过滤器1: 可用性过滤 (AvailabilityFilter)
```python
def apply(self, products: List[Product], context: FilterContext) -> List[Product]:
    """过滤掉不可用或已下架的商品"""
    return [p for p in products if p.is_available and p.status == "active"]
```

#### 过滤器2: 营养数据过滤 (NutritionDataFilter)
```python
def apply(self, products: List[Product], context: FilterContext) -> List[Product]:
    """过滤掉营养数据不完整的商品"""
    required_fields = ["energy_kcal_100g", "proteins_100g", "fat_100g", "carbohydrates_100g"]
    return [p for p in products if all(getattr(p.nutrition, field, None) is not None for field in required_fields)]
```

#### 过滤器3: 过敏原过滤 (AllergenFilter)
```python
def apply(self, products: List[Product], context: FilterContext) -> List[Product]:
    """过滤掉包含用户过敏原的商品"""
    user_allergens = context.user_profile.allergens
    safe_products = []
    
    for product in products:
        is_safe = True
        for allergen in user_allergens:
            if any(allergen.lower() in ingredient.lower() for ingredient in product.allergens):
                is_safe = False
                break
        if is_safe:
            safe_products.append(product)
    
    return safe_products
```

#### 过滤器4: 类别过滤 (CategoryFilter)
```python
def apply(self, products: List[Product], context: FilterContext) -> List[Product]:
    """过滤同类别商品，确保推荐的相关性"""
    original_category = context.original_product.category
    return [p for p in products if p.category == original_category]
```

### 5.2 营养优化评分 (Nutrition Optimizer)

#### 评分策略配置
```python
NUTRITION_STRATEGIES = {
    "WEIGHT_LOSS": {
        "energy_kcal_100g": -0.4,    # 低热量优先
        "fat_100g": -0.3,            # 低脂肪
        "sugars_100g": -0.5,         # 低糖分
        "proteins_100g": 0.3,        # 高蛋白质
        "fiber_100g": 0.4,           # 高纤维
        "salt_100g": -0.2            # 低盐分
    },
    "MUSCLE_GAIN": {
        "proteins_100g": 0.6,        # 高蛋白质优先
        "carbohydrates_100g": 0.3,   # 适量碳水
        "energy_kcal_100g": 0.4,     # 充足热量
        "fat_100g": 0.1              # 适量脂肪
    },
    "HEALTH_MAINTENANCE": {
        "balance_score": 0.4,        # 营养均衡
        "variety_score": 0.3,        # 营养多样性
        "natural_ingredients": 0.3   # 天然成分优先
    }
}
```

#### 评分计算公式
```python
def calculate_nutrition_score(self, product: Product, user_profile: UserProfile) -> float:
    strategy = NUTRITION_STRATEGIES[user_profile.nutrition_goal]
    base_score = 0.0
    
    for nutrient, weight in strategy.items():
        if hasattr(product.nutrition, nutrient):
            nutrient_value = getattr(product.nutrition, nutrient)
            normalized_value = self._normalize_nutrient_value(nutrient, nutrient_value)
            base_score += normalized_value * weight
    
    # 应用活动水平调整
    activity_multiplier = self._get_activity_multiplier(user_profile.activity_level)
    
    return max(0.0, min(1.0, base_score * activity_multiplier))
```

## 6. LLM集成规范

### 6.1 Prompt模板管理

#### 模板结构
```python
class PromptTemplateManager:
    def __init__(self):
        self.templates = {
            "barcode_scan": self._get_barcode_scan_template(),
            "receipt_analysis": self._get_receipt_analysis_template(),
            "nutrition_comparison": self._get_nutrition_comparison_template(),
            "allergen_warning": self._get_allergen_warning_template()
        }
    
    def generate_barcode_scan_prompt(self, context: PromptContext) -> str:
        template = self.templates["barcode_scan"]
        
        return template.format(
            age=context.user_profile.get("age", "Unknown"),
            gender=self._translate_gender(context.user_profile.get("gender", "")),
            nutrition_goal_en=self._translate_nutrition_goal(context.user_profile.get("nutrition_goal", "")),
            activity_level_en=self._translate_activity_level(context.user_profile.get("activity_level", "")),
            allergens_list=self._format_allergens_list(context.user_profile.get("allergens", [])),
            original_product_name=context.original_product.get("name", "Unknown"),
            original_calories=context.original_product.get("nutrition", {}).get("energy_kcal_100g", "Unknown"),
            recommended_products_details=self._format_recommended_products(context.recommended_products)
        )
```

#### 条码扫描模板
```python
def _get_barcode_scan_template(self) -> str:
    return """You are a professional nutritionist and food safety expert. A user has scanned a product barcode, please provide professional, personalized alternative product recommendation analysis.

User Profile:
- Basic Information: {age} years old {gender}, height {height_cm}cm, weight {weight_kg}kg
- Nutrition Goal: {nutrition_goal_en}
- Activity Level: {activity_level_en}
- Known Allergens: {allergens_list}

Scanned Original Product:
- Product Name: {original_product_name}
- Nutrition Facts (per 100g):
  * Calories: {original_calories}kcal
  * Protein: {original_protein}g
  * Sugar: {original_sugar}g

Recommended Alternatives:
{recommended_products_details}

### Output Format Requirements ###
Please return your analysis strictly in the following JSON format, without any extra explanations, Markdown formatting, or code blocks:

{{
  "summary": "One sentence core assessment based on user's {nutrition_goal_en} goal and {activity_level_en} activity level (40-60 words)",
  "detailedAnalysis": "Detailed nutrition analysis with specific data from comparison above, explaining why this product aligns or doesn't align with user goals (80-120 words). All output fields must be in English.", 
  "actionSuggestions": [
    "Specific actionable suggestion 1 based on recommended alternatives",
    "Specific actionable suggestion 2 for achieving nutrition goals",
    "Specific actionable suggestion 3 for better choices"
  ]
}}

Please ensure your reply is in pure JSON format for easy program parsing."""
```

### 6.2 LLM响应验证

```python
def _validate_llm_response(self, llm_data: Dict[str, Any]) -> Dict[str, Any]:
    """验证LLM响应格式和内容质量"""
    required_fields = ["summary", "detailedAnalysis", "actionSuggestions"]
    
    # 1. 字段完整性检查
    for field in required_fields:
        if field not in llm_data:
            raise ValueError(f"Missing required field: {field}")
    
    # 2. 内容长度验证
    if len(llm_data["summary"]) < 20:
        raise ValueError("Summary too short")
    
    if len(llm_data["detailedAnalysis"]) < 50:
        raise ValueError("Detailed analysis too short")
    
    if len(llm_data["actionSuggestions"]) < 2:
        raise ValueError("Need at least 2 action suggestions")
    
    # 3. 语言检测 (确保英文输出)
    if self._detect_language(llm_data["summary"]) != "en":
        raise ValueError("Response must be in English")
    
    return llm_data
```

## 7. 前端集成规范

### 7.1 API调用层 (ApiService)

```dart
class ApiService {
  static const String _baseUrl = 'http://localhost:8080';
  
  Future<Map<String, dynamic>> getBarcodeRecommendation({
    required int userId,
    required String barcode,
  }) async {
    final response = await http.post(
      Uri.parse('$_baseUrl/recommendations/barcode'),
      headers: {'Content-Type': 'application/json'},
      body: json.encode({
        'userId': userId,
        'productBarcode': barcode,
      }),
    );
    
    if (response.statusCode == 200) {
      return json.decode(response.body);
    } else {
      throw Exception('Failed to get recommendations: ${response.statusCode}');
    }
  }
}
```

### 7.2 数据模型层 (ProductAnalysis)

```dart
class ProductAnalysis {
  final String name;
  final String brand;
  final String? barcode;
  final String summary;
  final String detailedAnalysis;
  final List<String> actionSuggestions;
  final List<ProductAnalysis> recommendations;
  final List<String> detectedAllergens;
  final String ingredients;
  
  ProductAnalysis({
    required this.name,
    required this.brand,
    this.barcode,
    required this.summary,
    required this.detailedAnalysis,
    required this.actionSuggestions,
    required this.recommendations,
    required this.detectedAllergens,
    required this.ingredients,
  });
  
  factory ProductAnalysis.fromJson(Map<String, dynamic> json) {
    return ProductAnalysis(
      name: json['name'] ?? 'Unknown Product',
      brand: json['brand'] ?? 'Unknown Brand',
      barcode: json['barcode'],
      summary: json['summary'] ?? '',
      detailedAnalysis: json['detailedAnalysis'] ?? '',
      actionSuggestions: List<String>.from(json['actionSuggestions'] ?? []),
      recommendations: (json['recommendations'] as List?)
          ?.map((item) => ProductAnalysis.fromJson(item))
          .toList() ?? [],
      detectedAllergens: List<String>.from(json['detectedAllergens'] ?? []),
      ingredients: json['ingredients'] ?? '',
    );
  }
}
```

### 7.3 UI展示规范

#### 扫描页面展示 (简化版)
```dart
Widget _buildLLMAnalysisCard() {
  return Container(
    padding: EdgeInsets.all(16),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 标题
        Row(
          children: [
            Icon(Icons.psychology, color: AppColors.primary, size: 20),
            SizedBox(width: 8),
            Text('AI Nutrition Analysis', style: AppStyles.cardTitle),
          ],
        ),
        SizedBox(height: 16),
        
        // 摘要信息 (仅显示summary)
        _buildAnalysisField(
          icon: Icons.summarize,
          title: 'Summary',
          content: _currentAnalysis!.summary,
          color: Colors.orange,
        ),
        
        // 推荐产品列表
        if (_currentAnalysis!.recommendations.isNotEmpty) ...[
          SizedBox(height: 16),
          _buildRecommendationsList(),
        ],
        
        SizedBox(height: 16),
        
        // View Details按钮
        _buildViewDetailsButton(),
      ],
    ),
  );
}
```

#### 详情页面展示 (完整版)
```dart
Widget _buildDetailedAnalysis() {
  return Container(
    padding: EdgeInsets.all(16),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 详细分析
        _buildAnalysisField(
          icon: Icons.analytics,
          title: 'Detailed Analysis',
          content: widget.productAnalysis.detailedAnalysis,
          color: Colors.indigo,
        ),
        
        SizedBox(height: 20),
        
        // 行动建议
        _buildActionSuggestions(),
        
        SizedBox(height: 20),
        
        // 替代产品
        _buildAlternativeProducts(),
      ],
    ),
  );
}
```

## 8. 错误处理和降级策略

### 8.1 多层错误处理机制

#### Java层错误处理
```java
@ExceptionHandler(Exception.class)
public ResponseMessage<Object> handleException(Exception e) {
    logger.error("Recommendation service error: ", e);
    
    return new ResponseMessage<>(
        500, 
        "系统暂时不可用，请稍后重试", 
        null
    );
}
```

#### Python层错误处理
```python
async def safe_llm_call(self, prompt: str) -> Dict[str, Any]:
    try:
        response = await self.openai_client.generate_analysis(prompt)
        return response
    except OpenAIError as e:
        logger.warning(f"LLM service unavailable: {e}")
        return self._get_fallback_analysis()
    except Exception as e:
        logger.error(f"Unexpected error in LLM call: {e}")
        return self._get_fallback_analysis()

def _get_fallback_analysis(self) -> Dict[str, Any]:
    """LLM服务不可用时的降级分析"""
    return {
        "summary": "Product analysis based on nutritional data suggests considering alternatives aligned with your health goals.",
        "detailedAnalysis": "This product may not be optimal for your current nutrition objectives. Consider reviewing the recommended alternatives for better nutritional value.",
        "actionSuggestions": [
            "Review the recommended alternative products",
            "Check nutritional labels before purchasing",
            "Consult with a nutritionist for personalized advice"
        ]
    }
```

### 8.2 数据一致性保障

#### 数据库事务管理
```java
@Transactional
public ResponseMessage<Object> processRecommendation(Map<String, Object> request, RecommendationLog log) {
    try {
        // 1. 保存初始日志
        log.setCreatedAt(new Timestamp(System.currentTimeMillis()));
        recommendationLogRepository.save(log);
        
        // 2. 调用推荐服务
        Map<String, Object> response = callRecommendationService(request);
        
        // 3. 更新日志结果
        log.setRecommendedProducts(objectMapper.writeValueAsString(response.get("data")));
        log.setProcessingTimeMs(calculateProcessingTime());
        recommendationLogRepository.save(log);
        
        return new ResponseMessage<>(200, "推荐获取成功", response);
        
    } catch (Exception e) {
        // 4. 错误日志记录
        log.setErrorMessage(e.getMessage());
        recommendationLogRepository.save(log);
        
        return new ResponseMessage<>(500, "推荐服务调用失败: " + e.getMessage(), null);
    }
}
```

## 9. 性能优化和监控

### 9.1 缓存策略

#### Redis缓存配置
```python
CACHE_CONFIG = {
    "redis": {
        "host": "localhost",
        "port": 6379,
        "db": 0,
        "password": None,
        "max_connections": 20
    },
    "ttl": {
        "user_profile": 3600,        # 用户画像缓存1小时
        "product_info": 1800,        # 商品信息缓存30分钟
        "recommendation_results": 900, # 推荐结果缓存15分钟
        "llm_responses": 1800        # LLM响应缓存30分钟
    }
}

async def get_cached_recommendation(self, cache_key: str) -> Optional[Dict[str, Any]]:
    try:
        cached_data = await self.redis_client.get(cache_key)
        if cached_data:
            return json.loads(cached_data)
    except Exception as e:
        logger.warning(f"Cache retrieval failed: {e}")
    
    return None
```

### 9.2 性能指标监控

#### 响应时间监控
```python
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {
            "total_requests": 0,
            "successful_requests": 0,
            "average_response_time": 0.0,
            "llm_call_time": 0.0,
            "database_query_time": 0.0
        }
    
    @contextmanager
    def measure_time(self, operation: str):
        start_time = time.time()
        try:
            yield
        finally:
            duration = time.time() - start_time
            self._record_timing(operation, duration)
    
    def _record_timing(self, operation: str, duration: float):
        self.metrics[f"{operation}_time"] = duration
        logger.info(f"Performance: {operation} took {duration:.2f}s")
```

### 9.3 资源使用优化

#### 并发处理配置
```python
# FastAPI应用配置
app = FastAPI(
    title="Grocery Guardian Recommendation API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# 限制并发请求数
semaphore = asyncio.Semaphore(10)

@app.middleware("http")
async def limit_concurrent_requests(request: Request, call_next):
    async with semaphore:
        response = await call_next(request)
        return response
```

## 10. 部署和环境配置

### 10.1 开发环境配置

#### Java应用配置 (application.properties)
```properties
# 推荐服务配置
recommendation.service.base-url=http://localhost:8001
recommendation.service.api-token=123456
recommendation.service.timeout=30000

# 数据库配置
spring.datasource.url=jdbc:mysql://localhost:3306/springboot_demo
spring.datasource.username=root
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update

# 产品服务配置
product.service.base-url=http://localhost:8082/api
product.service.timeout=5000
```

#### Python环境配置 (.env)
```bash
# 环境配置
ENVIRONMENT=development
DEBUG=true

# 数据库配置
DB_TYPE=mysql
MYSQL_CONNECTION_STRING=mysql+pymysql://root:password@localhost:3306/springboot_demo

# OpenAI配置
OPENAI_API_KEY=your_openai_api_key_here
OPENAI_MODEL=gpt-4
OPENAI_MAX_TOKENS=1000

# Redis配置
REDIS_URL=redis://localhost:6379/0

# 日志配置
LOG_LEVEL=INFO
LOG_FILE=logs/recommendation.log
```

### 10.2 生产环境部署

#### Docker配置
```dockerfile
# Python推荐服务
FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["uvicorn", "api.main:app", "--host", "0.0.0.0", "--port", "8001"]
```

#### 服务启动脚本
```bash
#!/bin/bash
# start_services.sh

# 启动Java后端服务
echo "Starting Java backend service..."
cd Backend
mvn spring-boot:run &
JAVA_PID=$!

# 启动Python推荐服务
echo "Starting Python recommendation service..."
cd ../Recommendation/src/main/java/org/recommendation/Rec_LLM_Module
python debug_start.py &
PYTHON_PID=$!

# 启动Flutter前端
echo "Starting Flutter frontend..."
cd ../../../../../7.6-version2-frontend
flutter run -d chrome --web-port 62976 &
FLUTTER_PID=$!

echo "All services started successfully"
echo "Java PID: $JAVA_PID"
echo "Python PID: $PYTHON_PID"
echo "Flutter PID: $FLUTTER_PID"
```

## 11. 总结和最佳实践

### 11.1 架构设计原则

1. **分层解耦**: Java负责API网关和数据持久化，Python专注推荐算法和LLM集成
2. **数据驱动**: 基于真实营养数据和用户画像进行个性化推荐
3. **安全第一**: 严格的过敏原过滤和营养目标对齐
4. **性能优化**: 多级缓存、异步处理、并发控制
5. **可扩展性**: 模块化设计，支持新算法和数据源集成

### 11.2 开发最佳实践

1. **API设计**: 严格遵循RESTful原则，统一响应格式
2. **错误处理**: 多层错误处理机制，优雅降级
3. **数据验证**: 输入验证、输出格式验证、业务逻辑验证
4. **性能监控**: 实时性能指标收集和分析
5. **文档维护**: 及时更新API文档和系统架构文档

### 11.3 质量保证措施

1. **端到端测试**: 完整的用户场景测试覆盖
2. **单元测试**: 核心算法和业务逻辑单元测试
3. **集成测试**: 跨服务集成测试验证
4. **性能测试**: 负载测试和压力测试
5. **安全测试**: 数据安全和API安全测试

---

**文档版本**: v1.0  
**最后更新**: 2025-07-10  
**维护团队**: 推荐系统开发组